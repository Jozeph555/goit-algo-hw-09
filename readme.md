# Алгоритми видачі решти

## Опис задачі

Маємо набір монет фіксованих номіналів: `[50, 25, 10, 5, 2, 1]`. Потрібно розробити систему для касового апарату, яка визначатиме оптимальний спосіб видачі решти покупцю.

## Реалізовані алгоритми

### 1. Жадібний алгоритм (`find_coins_greedy`)

* **Принцип роботи**: На кожному кроці вибирає монету найбільшого можливого номіналу
* **Складність**: O(n), де n - кількість номіналів монет
* **Переваги**: 
    * Простий в реалізації
    * Надзвичайно швидкий час виконання
    * Підходить для стандартних наборів монет
* **Недоліки**:
    * Не гарантує оптимальне рішення для всіх можливих наборів монет

### 2. Алгоритм динамічного програмування (`find_min_coins`)

* **Принцип роботи**: Знаходить оптимальне рішення для кожної проміжної суми
* **Складність**: O(amount * n), де amount - сума, n - кількість номіналів монет
* **Переваги**:
    * Гарантує мінімальну кількість монет
    * Знаходить оптимальне рішення для будь-якого набору монет
* **Недоліки**:
    * Потребує більше пам'яті
    * Значно повільніший для великих сум

## Результати тестування

### Порівняння результатів для різних сум:

#### Сума: 113
```python
Жадібний алгоритм: {50: 2, 10: 1, 2: 1, 1: 1}
Динамічне програмування: {50: 2, 10: 1, 2: 1, 1: 1}
```

#### Сума: 1500
```python
Жадібний алгоритм: {50: 30}
Динамічне програмування: {50: 30}
```

#### Сума: 15000
```python
Жадібний алгоритм: {50: 300}
Динамічне програмування: {50: 300}
```

#### Сума: 150000
```python
Жадібний алгоритм: {50: 3000}
Динамічне програмування: {50: 3000}
```

### Порівняння часу виконання:

| Сума    | Жадібний алгоритм (сек)| Динамічне програмування (сек)| Різниця (разів) |
|---------|------------------------|------------------------------|-----------------|
| 113     | 0.000002               | 0.000034                     | 17              |
| 1500    | 0.000001               | 0.000456                     | 456             |
| 15000   | 0.000001               | 0.005061                     | 5061            |
| 150000  | 0.000001               | 0.057478                     | 57478           |

### Аналіз результатів

1. **Точність результатів**:
   * Обидва алгоритми дають однакові результати для всіх тестових сум
   * Для даного набору монет жадібний алгоритм завжди знаходить оптимальне рішення

2. **Швидкодія**:
   * Жадібний алгоритм показує стабільно швидкий час виконання (близько 0.000001-0.000002 сек) незалежно від розміру суми
   * Час виконання алгоритму динамічного програмування значно зростає зі збільшенням суми:
     - Для суми 113: в 17 разів повільніше
     - Для суми 1500: в 456 разів повільніше
     - Для суми 15000: в 5061 разів повільніше
     - Для суми 150000: в 57478 разів повільніше

3. **Масштабованість**:
   * Жадібний алгоритм демонструє відмінну масштабованість - час практично не змінюється зі зростанням суми
   * Динамічне програмування показує лінійне зростання часу виконання зі збільшенням суми

## Висновки

1. Для даного набору монет жадібний алгоритм є однозначно кращим вибором:
   * Дає такі ж оптимальні результати, як і динамічне програмування
   * Працює на 4-5 порядків швидше для великих сум
   * Використовує мінімум пам'яті
   * Показує стабільну швидкодію незалежно від розміру суми

2. Алгоритм динамічного програмування в даному випадку не має практичних переваг:
   * Дає такі ж результати, як і жадібний алгоритм
   * Потребує значно більше часу на виконання
   * Споживає більше пам'яті
   * Може бути корисним лише для інших наборів монет, де жадібний алгоритм не гарантує оптимального результату
